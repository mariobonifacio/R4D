---
title: "Assignment 2"
author: "~~Hari Subhash~~ Mario"
date: 'Date created: `r Sys.Date()`'
output:
  html_notebook:
    code_folding: show
    df_print: paged
    highlight: kate
    smart: yes
    theme: paper
    toc: no
  html_document:
    toc: no
---

# {.tabset .tabset-fade .tabset-pills}

## Abstract 

Unpredictable flight delays are a costly problem, forcing travelers to choose between spending unproductive time at the airport and missing a flight. In 2013, flights from the three New York area airports alone saw aggregate delays of half a million minutes. I explore the predictive capacity with respect to the probability of departure delay of five variables -- **scheduled departure time**, **atmomspheric pressure**, **visibility**, **the probability associated with each air carrier**, and **the probability associated with each origin airport**. Notably all five of these variables are forecasted ahead of time and made publicly available.

Of those five variables, it's **scheduled departure time** that is most closely associated with the probability of delay.

## Background

**PROBLEM:** Here, the problem is that flight delays are unpredictable. Not only that, mis-timing your ride to the airport could be costly; Arrive late and you may miss your flight altogether, but arrive early and you'll spend even more uncomfortable, unproductive time at the gate. In an ideal world, all flights would simply leave on time. In a second-best world, each airline would contact travelers directly with flight delay information that was accurate and timely enough to be actionable. Alas, neither of those are the case.

**GOAL:** My ultimate goal is to be able to best predict whether a flight will be delayed using weather, plane, and flight data.

**HYPOTHESIS:** My null hypothesis is that *no* available weather, plane, or flight data shares a relationship with flight delay. I'll seek to disprove this.

## Setting up

To set up, I'll do the following:

1. Link flight data with data to the planes flown and the weather contemporaneous to each flight
2. Find a baseline probability for departure delay
3. Clean and adapt the data both so that it makes sense logically and is testable; This will include:
    a. Setting negative departure delay values equal to zero^1^
    b. Replacing categorical data -- such as the name of an airline -- with an "object effect" that estimates the added chance for delay associated with any object
4. Start an appendix of metadata, including:
    a. A data dictionary
    b. A data lineage diagram


```{r message=FALSE, warning=FALSE}
### On the code side, I'll do the following:

# 1. Install and enable R packages to explore, manipulate, and analyze the data
# 2. Finding a baseline for departure delay by counting delayed and on-time flights 
# 3. Use common fields to join flight table w/weather and plane tables
# 4. Select columns to be removed
# 5. Mutate some columns so they're more useful. Specifically, I group categorical variables and estimate a conditional probability using observed delay data

### 1. Install packages, as needed 
# install.packages('tidyverse'); install.packages('skimr'); install.package('lubridate');
# install.packages('ggthemes'); install.packages('DiagrammeR')

# This line enable packages
library(tidyverse); library(skimr); library(nycflights13); library(lubridate); library(ggthemes); library(reshape2); library(DiagrammeR)
```

```{r}
### 2. Here, I use math to 

op_base <- (flights %>% filter(dep_delay > 0) %>% nrow()) / (flights %>% filter(!is.na(dep_delay) == T) %>% nrow())


```


```{r}
### 3. Join flight, plane, and weather data into a single data frame of raw data to work with
flt_raw <- flights %>%
  left_join(rename(planes,'manuf_year' = year), by = 'tailnum') %>% ## Rename plane manufacture year from 'year' to 'manuf_year' to not confuse it with flight year
  left_join(weather, by = c('time_hour', 'origin'))
```


```{r}
### 3,4. Remove irrelevant columns and transform categorical data into numbers


flt_test <- flt_raw %>%
  filter(!is.na(dep_delay) == T) %>%
  select(dep_delay, sched_dep_time, distance, manuf_year, engines ## 1-5
         ,seats, temp, dewp, humid, wind_speed,wind_gust, precip ## 6-12
         ,pressure, visib, distance ## 13-15
         ,carrier, origin, type, manufacturer ## cat cols 16-19
         ,model, speed ,engine) %>% ## cat cols 20-22
  mutate(diff_20h = if_else(sched_dep_time < 2000
                            ,1960 - sched_dep_time
                            ,sched_dep_time - 2000)
                            ,dep_delay = if_else(dep_delay > 0, 1, 0)) %>%
  group_by(carrier) %>%
     mutate(op_carr = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup() %>%
  group_by(origin) %>%
     mutate(op_ogn = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup() %>%
  group_by(type) %>%
     mutate(op_type = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup() %>%
  group_by(manufacturer) %>%
     mutate(op_mnf = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup() %>%
  group_by(model) %>%
     mutate(op_mdl = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup() %>%
  group_by(speed) %>%
     mutate(op_spd = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup() %>%
  group_by(engine) %>%
     mutate(op_eng = sum(dep_delay>0) / length(dep_delay) - op_base) %>%
     ungroup()
```

```{r}
### This code creates a separate data frame which links categorical variables to their relative probabilities
cat_facts <- flt_test %>%
  select(15:21,23:29) %>%
  unique()

## Now, I'll gather and do a little clean-up

cat_facts <- cat_facts %>%
  gather(key = 'cat', value = 'obj', carrier, origin, type, manufacturer, model, speed, engine) %>%
  rename(carrier = op_carr
         ,origin = op_ogn
           ,type = op_type
   ,manufacturer = op_mnf
          ,model = op_mdl
          ,speed = op_spd
         ,engine = op_eng) %>%
  gather(key = 'trans', value = 'facts', 1:7) %>%
  filter(cat == trans) %>%
  select(-trans) %>%
  unique() %>%
  filter(!is.na(obj) == T) %>%
  arrange(cat,desc(facts))

cat_facts
```  
  
```{r}
### This code removes the original categorical variables to get the data frame even skinnier; Can reference cat_facts if needed

flt_test <- flt_test %>%
  select(-(15:21))

flt_test %>%
  cor(use = 'pairwise.complete.obs') %>%
  as_tibble() %>%
  mutate(field = rownames(cor(flt_test))) %>%
  filter(dep_delay < 1) %>%
  select(field, dep_delay) %>%
  arrange(desc(abs(dep_delay)))



```

^1^ A negative departure delay value would decrease a category mean as though it *is* more on time.  A flight that leaves early should not be considered "more on time" than a flight that leaves at it's scheduled time. To better intuit this, suppose an airline has one flight that leaves 30 minutes early and another that leaves 30 minutes late. On paper it would appear that a traveler need not worry about delays when flying on this airline, but this is not the case. Because of that, I chose to zero out negative departure delay values.

## Univariate analysis

Here are the steps for this

1. Explore metadata to ensure I understand what each variable represents
2. Descriptive statics of the dependent variable, departure delay, including number of observations, mean, standard deviation, median, min, max, and interquartile measures
3. Descriptive statistics for the independent variables
4. A histogram will offer a visual representation of each

Doing this will expose:

* Fields that would be unlikely related to departure delay,
* Fields that will require transformation, and
* Fields with too few observations or with too many missing observations to be representative

**DATA DICTIONARY**

* **year,month,day:** Date of departure or date of weather recording
* **dep_time,arr_time:** Actual departure and arrival times (format HHMM or HMM), local tz.
* **sched_dep_time,sched_arr_time:** Scheduled departure and arrival times (format HHMM or HMM), local tz.
* **dep_delay,arr_delay:** Departure and arrival delays, in minutes. Negative times represent early departures/arrivals.
* **hour** Hour part of time of scheduled departure or weather recording
* **minute:** Minute part of time of scheduled departure
* **carrier:** Two letter carrier abbreviation. See airlines() to get name
* **tailnum:** Plane tail number
* **flight:** Flight number
* **origin:** Origin of flight or weather station. Origin + time_hour can be used to join flight and weather data
* **dest:** Destination of flight. See airports() for additional metadata.
* **air_time:** Amount of time spent in the air, in minutes
* **distance:** Distance between airports, in miles
* **time_hour:** Scheduled date and hour of the flight or of the weather recording as a POSIXct date. Origin + time_hour can be used to join flight and weather data
* **temp,dewp:** Temperature and dewpoint in F
* **humid:** Relative humidity
* **wind_dir,wind_speed,wind_gust:** Wind direction (in degrees), speed and gust speed (in mph)
* **precip:** Precipitation, in inches
* **pressure:** Sea level pressure in millibars
* **visib:** Visibility in miles

**DESCRIPTIVE STATS OF THE DEPENDENT VARIABLE:** 

First, I'll prepare a histogram of departure delay. I'll cut off at the 97.5th percentile so it's easier to see

```{r}
flights %>% ##
  select(dep_delay) %>%
  filter(!is.na(dep_delay) == T
           & dep_delay < as.numeric(quantile(flights %>%
           filter(!is.na(dep_delay) ==T) %>%
           select(dep_delay) %>%
           as_vector(), probs = .975))) %>%
  mutate(dep_delay = (dep_delay + abs(dep_delay)) / 2) %>%
  as_tibble() %>%
  ggplot(data = ., mapping = aes(x = dep_delay)) +
  geom_histogram(binwidth = 5, na.rm = T) +
  theme_economist() +
  ggtitle('Departure delay is skewed right and not normally distributed')
  
```
Let's look at some percentiles to verify that this is not normal by checking the probabilities associated with one-tailed z-scores of 0.5 to 3.0
```{r}
quantile(flights %>%
           filter(!is.na(dep_delay) ==T) %>%
           select(dep_delay) %>%
           mutate(dep_delay = (dep_delay + abs(dep_delay))/2) %>%
           as_vector(), probs = c(0.6915, 0.8413,0.9332 ## p(z < 0.5, 1.0, 1.5)
                                  ,0.9772, 0.9938, 0.9987)) ## p(z < 2.0, 2.5, 3.0)
```
In a normal distribution, the distance between each of these would be equal. 

```{r}




```


The following fields are either unlikely to be related to departure delay or duplicative of another, superior field in the data set

* Destination
* Tail number
* Arrival time
* Day of the month
* Flight number
* Scheduled arrival time
* Year
* Air time
* Arrival delay
* Departure time
* Distance

Only one field among those remaining, **wind gust**, is concerning due to the number of n/a entries -- 256,391 of 336,776 total. My fear is that these incomplete entries are biased -- that is, we may be telling a story that is based on a sample of the data that does not represent the poopulation.
```{r}
### Here, I split up all entries based on whether or not wind_gust is NULL
### Then, look at descriptive statistics of delay by those groups
flt_test %>%
  select(wind_gust,dep_delay) %>%
  filter(is.na(dep_delay) == F) %>%
  mutate(na_gust = if_else(is.na(wind_gust), 0, 1)) %>% 
  group_by(na_gust) %>% 
  summarise(p_del = sum(dep_delay > 0)/length(dep_delay) 
     ,n_del     = length(dep_delay)
     ,min_del    = min(dep_delay,na.rm = T)
     ,del_25qile = quantile(dep_delay,probs = 0.25,na.rm = T)
     ,mdn_del    = median(dep_delay,na.rm = T)
     ,del_75qile = quantile(dep_delay,probs = 0.75,na.rm = T)
     ,max_del    = max(dep_delay, na.rm = T)) %>%
    round(2)

flt_test %>%
  select(wind_gust,dep_delay) %>%
  filter(is.na(dep_delay) == F) %>%
  mutate(na_gust = factor(if_else(is.na(wind_gust), 0, 1)
                             ,levels = c(0,1)
                             ,labels = c('null', 'not null') )) %>%
  ggplot(aes(dep_delay)) +
  geom_density() +
  ggtitle(label = 'Dep. delay differs when wind gust is na but is good enough to use') +
  theme_economist() +
  facet_wrap(~na_gust, nrow = 2, ncol = 1)
```
These look similar enough to work with. To verify with numbers, I would do a z-test to see if I'm able to disprove that the means are unequal and an f-test to do the same with the standard deviations. But not today. Today, I will do neither.

## Multivariate analysis

There are steps here

1. Test relationships
2. Find correlation
3. Linear model the best

**FINDING SIGNIFICANT RELATIONSHIPS:**

In testing departure delay and our other variables, I'll be looking for relationships that show a strong, correlative relationship. 

To do this, I'll use R's general linear model (glm) tool. This will expose the strength of each relationship by providing a p-value, which estimates the probability that we'd get at least as extreme a result if NYC flights 2013 were repeated forever. Because we want there to be *little* chance that sampling the actual population gives us results that are extreme relative to our model, we want p-values that are as low as possible.

**I will test the dataset I've created with a significance level of 0.1 percent.**
```{r, message=FALSE, warning=FALSE}
glm_test <- glm(data = flt_test, dep_delay ~ diff_20h + distance + manuf_year + engines + seats + temp + dewp + humid + wind_speed + wind_gust + precip + pressure + visib + op_carr + op_ogn + op_type + op_mnf + op_mdl + op_spd + op_eng, family = binomial)

glm_test <- glm(data = flt_test, dep_delay ~ diff_20h + humid + pressure + visib + op_carr + op_ogn + op_mnf + op_mdl + op_eng, family = binomial)

(summary(glm_test))

```
The variables that appear to have significant relationships with dep_delay are: diff_20h, humidity, pressure, visibility, op_carr, op_ogn, op_mnf, op_mdl, op_eng

```{r}
flt_test %>%
  select(diff_20h, humid, pressure, visib, op_carr, op_ogn, op_mnf, op_mdl, op_eng) %>%
  cor(use = 'pairwise.complete.obs') %>%
  round(2) %>%
  as_tibble() %>%
  mutate(field = c('diff_20h', 'humid', 'pressure', 'visib', 'op_carr', 'op_ogn', 'op_mnf', 'op_mdl', 'op_eng'))
```
In seeing this correlation table, it's clear that some of our predictor variables may be comingling with each other. I'll tabulate only the high values so it's easier to read
```{r}
tibble(humid = c(.54, NaN, NaN, NaN, NaN)
       ,op_carr = c(NaN, 0.45, 0.52, 0.79, 0.37)
       ,op_ogn = c(NaN, NaN, .36, .48, NaN)
       ,op_mnf = c(NaN, NaN, NaN, .58, .59)
       ,op_mdl = c(NaN, NaN, NaN, NaN, .35)
       ,field = c("visib", "op_ogn", "op_mnf", "op_mdl", "op_eng"))

```
Humidity is highly correlated with visibility. This makes sense since water vapor in the air makes it more difficult to see.
   -humid

Carrier is highly correlated with four variables which are also correlated with each other -- airport of origin, manufacturer, model, and engine. This makes sense because having more of its planes concentrated at one airport provides economies of scale and manufacturers -- who sell plane models with engines in them -- are likely to cut a deal with those who buy in bulk.
   -op_mnf, -op_mdl, -op_eng
   
This brings us to our final five variables: diff_20h, pressure, visib, op_carr, op_ogn

```{r}
flt_final <- flt_test %>%
  select(dep_delay, diff_20h, pressure, visib, op_carr, op_ogn)
```

To figure out which single variable is most closely associated with probability of flight delay, I'll build another logistic regression model
```{r}
glm_test <- glm(data = flt_final, dep_delay ~ diff_20h + pressure + visib + op_carr + op_ogn, family = binomial)

summary(glm_test)

for(i in 1:6) print(as.numeric(coefficients(glm_test)[i]))
```
Here is the equation that estimates the probability of your flight being delayed using five inputs:

1/(1+e^-(
24.54178 
- 0.00116677 x diff_20h 
- 0.02320652 x pressure 
- 0.07679695 x visib 
+ 4.169445 x op_carr 
+ 1.73226 x op_ogn
))

To get a result with only one input, I can repeat the same:

```{r}
glm_test <- glm(data = flt_final, dep_delay ~ diff_20h, family = binomial)

summary(glm_test)

for(i in 1:2) print(as.numeric(coefficients(glm_test)[i]))
```
Here is the equation that estimates the probability of your flight being delayed using one input:

1/(1+e^-(0.2746527 - 0.001169423 x diff_20h))

```{r}
flt_final %>%
  mutate(pred_time_del = 1/(1+exp(-(0.2746527 - 0.001169423 * diff_20h)))) %>%
  ggplot(mapping = aes(diff_20h, pred_time_del)) +
  geom_point() +
  theme_economist()





test_a <- flights %>% ### flights[sample(nrow(flights),100),] %>% # Use this for sampling
  select(sched_dep_time, dep_delay) %>%
  filter(!is.na(dep_delay) == T) %>%
  filter(sched_dep_time %in% (flights %>%
             group_by(sched_dep_time) %>%
             summarise(n = length(sched_dep_time)) %>%
             filter(n >= 25) %>%
             select(sched_dep_time) %>%
             unique() %>%
             unlist() %>%
             as.character() %>%
             as.integer())) %>%
  mutate(is_delay = if_else(dep_delay > 0, 1, 0)
           ,diff_20h = if_else(sched_dep_time < 2000
                            ,1960 - sched_dep_time
                            ,sched_dep_time - 2000)) %>%
  group_by(diff_20h) %>%
  mutate(op_diff20 = sum(is_delay) / length(is_delay)) %>%
  ungroup() %>%
  as_tibble()



test_b <- cbind(test_a, tibble(sched_dep_time_diff_8pm = sample(0:1460, nrow(test_a),replace=T))) %>%
  mutate(prob_delay = 1/(1+exp(-(0.2746527 - 0.001169423 * sched_dep_time_diff_8pm))))



test_b %>%
  ggplot(aes(sched_dep_time_diff_8pm, prob_delay)) +
  geom_line(size = 1, color = 'red') +
  theme_fivethirtyeight() +
  geom_point(data = test_b, aes(x = diff_20h, y = op_diff20), color = 'gray') +
  geom_hline(yintercept = 0.39094, color='blue', size = 1)




  

```



