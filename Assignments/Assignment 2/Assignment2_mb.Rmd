---
title: "Assignment 2"
author: ~~Hari Subhash~~ Mario 
date: "Date created: `r Sys.Date()`"
output:
  html_notebook:
    highlight: kate
    smart: yes
    theme: cosmo
    code_folding: show
    df_print: paged
    toc: true
    toc_depth: 2
---

## Abstract

Unpredictable flight delays are a costly problem, forcing travelers to choose between . In 2013, flights from the three New York area airports alone saw aggregate delays of half a million minutes.

## Background

**PROBLEM:** Here, the problem is that flight delays are unpredictable. Not only that, mis-timing your ride to the airport could be costly; Arrive late and you may miss your flight altogether, but arrive early and you'll spend even more uncomfortable, unproductive time at the gate

**GOAL:** My ultimate goal is to be able to best predict a flight's departure delay. In an ideal world, all flights would simply leave on time. In a second-best world, each airline would contact travelers directly with flight delay information that was accurate and timely enough to be actionable. Alas, neither of those are the case and so in the world we live in, my goal is to better predict delay using weather and flight data.

**HYPOTHESIS:** My null hypothesis is that *no* available weather or flight data shares a relationship with flight delay. 


## Setting up

To set up, I'll do the following:

1. Install and enable the packages that will help explore, manipulate, and analyze the data
2. Join flight data with corresponding weather data 
3. 

```{r}
### Install packages, as needed 
# install.packages('tidyverse') 
# install.packages('skimr') 
# install.package('lubridate')
# install.packages('Hmisc')

# This line enables relevant packages
library(tidyverse); library(skimr); library(nycflights13); library(lubridate); library(Hmisc) 

### This joins flight and weather data, storing it in the new data frame we'll work with
flt_wx <- flights %>%
  left_join(weather,by = c('origin','time_hour')) %>%
  mutate(dep_delay = if_else(dep_delay<0, 0, dep_delay))

flt_wx
```

## Univariate analysis

Here's what I'll look at for each variable:

* Metadata will explain what each variable represents
* Descriptive variables including number of observations, mean, standard deviation, median, min, max, and interquartile measures
* A histogram will offer a visual representation of each

Doing this will expose:

* Fields that would be unlikely related to departure delay,
* Fields that will require transformation, and
* Fields with too few observations or with too many missing observations to be representative

```{r}
skim(flt_wx)
```
The following fields are either unlikely to be related to departure delay or duplicative of another, superior field in the data set

* Destination
* Tail number
* Arrival time
* Day of the month
* Flight number
* Scheduled arrival time
* Year
* Air time
* Arrival delay
* Departure time
* Distance

The following fields will need to be transformed in the succeeding ways:

* Departure delay -- replace negative values with 0
* Carrier -- Use difference between the mean delay of flights by a single carrier with mean delay overall
* Origin --  Use difference between the mean delay of flights that originate at a single airport with mean delay overall
* Time_hour -- Extract day of the week and convert to a dummy variable for whether the day is a weekend day
* Scheduled departure time -- Use difference with the hour of day of peak delays
* Month -- Use difference with the month of peak delays

Only one field among those remaining, **wind gust**, is concerning due to the number of n/a entries. My fear is that these incomplete entries are biased -- that is, we may be telling a story that is based on a sample of the data that does not represent the poopulation.
```{r}
library(tidyverse); library(skimr); library(nycflights13)

flt_wx %>%
  select(wind_gust,dep_delay) %>%
  filter(is.na(dep_delay) == F) %>%
  mutate(na_gust = if_else(is.na(wind_gust), 0, 1)) %>%
  group_by(na_gust) %>%
  mutate(pile = cut(dep_delay,5,labels = c('p20','p40','p60','p80','p99'))) %>%
     


  summarise(mean_del = mean(dep_delay,na.rm = T)
     ,n_del     = length(dep_delay)
     ,mean_del   = mean(dep_delay,na.rm = T)         
     ,stdev_del  = sd(dep_delay,na.rm = T)
     ,min_del    = min(dep_delay,na.rm = T)
     ,del_25qile = quantile(dep_delay,probs = 0.25,na.rm = T)
     ,mdn_del    = median(dep_delay,na.rm = T)
     ,del_75qile = quantile(dep_delay,probs = 0.75,na.rm = T)
     ,max_del    = max(dep_delay,na.rm = T))%>%
  
  round(2) %>%


cut(flt_wx$dep_delay, breaks = 5, labels = c('cut_1','cut_2','cut_3','cut_4','cut_5'))

flt_wx %>%
  select(wind_gust,dep_delay) %>%
  filter(is.na(dep_delay) == F) %>%
  mutate(na_gust = if_else(is.na(wind_gust), 0, 1)) %>%
  ggplot(aes(dep_delay)) +
  geom_density() +
  facet_wrap(~na_gust)
```
These look similar enough to work with.

Now to filter out the unused fields and transform other fields:


```{r}
flt_wx_cln <- flt_wx %>%
  filter(is.na(dep_delay) == F) %>%
  group_by(carrier) %>%
  mutate(dep_delay   = (abs(dep_delay)+dep_delay)/2 ## Zeroing negative delays
         ,carr_delay = mean(dep_delay,na.rm = T) - mean(flights$dep_delay,na.rm = T)
         ,is_wkend   = if_else(wday(as.Date(time_hour)) == 1 
            | wday(as.Date(time_hour)) == 7,1,0)
         ,diff_20hr  = if_else(sched_dep_time < 2000, 1960 - sched_dep_time, sched_dep_time - 2000)
         ,diff_7mo   = abs(month.x-7)) %>%
  ungroup() %>%
  group_by(origin) %>%
  mutate(ogn_delay = mean(dep_delay,na.rm = T) - mean(flights$dep_delay, na.rm = T)) %>%
  ungroup() %>%
  select(dep_delay, temp:ogn_delay)

%>%
  cor(use = 'pairwise.complete.obs', method = 'pearson') %>%
  round(2) %>%
  as.data.frame() %>%
  select(1) %>%
  cbind(rownames(.),.) %>%
  filter(dep_delay > -1 & dep_delay < 1) %>%
  arrange(desc(abs(dep_delay)))

flt_wx_cln
```


```{r}





 %>%
  group_by(carrier) %>%
  mutate(is_wkend = if_else(wday(as.Date(time_hour)) == 1 
            | wday(as.Date(time_hour)) == 7,1,0)
        ,near_20 = abs(hour.x - 20)
		    ,decness = abs(month.x - 6)
		    ,dep_delay = if_else(dep_delay<0,0,dep_delay)
        ,carr_delay = mean(dep_delay,na.rm = T)-mean(flights$dep_delay,na.rm = T)) %>%
  ungroup() %>%
  select(dep_delay,temp:carr_delay)

flt_wx %>%
  cor(use = 'pairwise.complete.obs', method = 'pearson') %>%
  round(2) %>%
  as.data.frame() %>%
  select(1) %>%
  cbind(rownames(.),.) %>%
  filter(dep_delay > -1 & dep_delay < 1) %>%
  arrange(desc(abs(dep_delay)))





flt_wx

skim(flights$dep_delay)
skim(flights$dep_delay[flights$dep_delay>0])




flt_wx

flt_wx %>%
  cor(use = 'pairwise.complete.obs',method = 'pearson') %>%
  round(2) %>%
  as.data.frame() %>%
  select(1) %>%
  cbind(rownames(.),.) %>%
  filter(dep_delay > 0 & dep_delay < 1) %>%
  arrange(desc(dep_delay))

flights %>%
  mutate(diff_20 = abs(hour-20)) %>% 
  select(dep_delay,hour,diff_20) %>%
  group_by(diff_20) %>%
  summarize(mean_delay = mean(dep_delay, na.rm = T)) %>%
#  arrange(desc(mean_delay)) %>%
#  cor(use = 'pairwise.complete.obs',method = 'pearson')
#
  ggplot(data = .,mapping = aes(x=diff_20,y=mean_delay)) +
  geom_point() +
  geom_smooth(method = lm)

# Block bits
# 0| |▁
# 1|▂|▃
# 2|▄|▅
# 3|▆|▇
# 4|█|

  
    cor(use = 'pairwise.complete.obs',method = 'pearson')



#
  ggplot(data = .,mapping = aes(x=wkday,y=mean_delay)) +
  geom_point() +
  geom_smooth(method = loess)
  

flights %>%
  mutate(diff_20 = abs(hour-20)) %>% 
  select(dep_delay,hour,diff_20) %>%
  group_by(diff_20) %>%
  summarize(mean_delay = mean(dep_delay, na.rm = T))

    
```
